// PlastiWatch V2 — SSD1306 OLED Display Driver (128×64, I2C)
//
// Custom register-level driver that implements `embedded_graphics::DrawTarget`.
// Manages a 1024-byte frame buffer flushed to the display via I2C.

use std::sync::Mutex;

use embedded_graphics::{
    draw_target::DrawTarget,
    geometry::{OriginDimensions, Point, Size},
    mono_font::{ascii::FONT_6X10, MonoTextStyle},
    pixelcolor::BinaryColor,
    prelude::*,
    primitives::{PrimitiveStyle, Rectangle},
    text::{Alignment, Text},
};
use esp_idf_hal::i2c::I2cDriver;

use crate::config::*;
use crate::events::ActivityClass;
use crate::drivers::sprites::{AnimationState, SPRITE_CENTER_X, SPRITE_CENTER_Y};

// ---------------------------------------------------------------------------
// PlastiBytes logo bitmap — 128×64 monochrome, SSD1306 page format
// Extracted from the original C++ DisplayDriver.
// ---------------------------------------------------------------------------
#[rustfmt::skip]
pub const LOGO_BITMAP: [u8; DISPLAY_BUFFER_SIZE] = [
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // Row 18 onward — logo content begins
    0x0f,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x10,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x20,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x60,0x00,0x00,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x40,0x00,0x01,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x40,0x00,0x03,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x40,0x00,0x03,0x04,0x00,0x07,0x80,0x00,0x00,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,
    0x40,0x00,0x07,0x04,0x7f,0x83,0x80,0x00,0x00,0x0e,0x1f,0xf0,0x00,0x00,0x00,0x00,
    0x40,0x00,0x0f,0x04,0x38,0xe3,0x80,0x00,0x00,0x0c,0x0c,0x18,0x00,0x00,0x00,0x00,
    0x40,0x1f,0xdf,0x04,0x38,0x73,0x80,0x00,0x03,0x00,0x0c,0x18,0x00,0x40,0x00,0x00,
    0x40,0x3f,0xfe,0x04,0x38,0x73,0x8f,0x83,0xc7,0x80,0x0c,0x19,0x00,0xe0,0xe0,0xe0,
    0x40,0x7f,0xbe,0x04,0x38,0x73,0x89,0xc6,0x67,0xde,0x0c,0x19,0x82,0xc3,0x31,0x10,
    0x40,0xff,0x7e,0x04,0x38,0x73,0x80,0xe6,0x07,0x0e,0x0e,0x70,0xc2,0xc2,0x13,0x00,
    0x40,0xfe,0xfe,0x04,0x38,0xe3,0x80,0xe7,0x07,0x0e,0x0e,0xf8,0xc4,0xc6,0x1b,0x00,
    0x40,0xfd,0xfe,0x04,0x3f,0xc3,0x83,0xe7,0xc7,0x0e,0x0c,0x0c,0x44,0xc7,0x39,0xc0,
    0x40,0xfd,0xfe,0x04,0x38,0x03,0x9e,0xe3,0xe7,0x0e,0x0c,0x0c,0x68,0xc6,0x00,0x70,
    0x40,0xfb,0xfc,0x04,0x38,0x03,0x9c,0xe0,0xe7,0x0e,0x0c,0x0c,0x68,0xc6,0x00,0x30,
    0x40,0xf7,0xf8,0x04,0x38,0x03,0x98,0xe0,0x67,0x0e,0x0c,0x0c,0x38,0xc2,0x00,0x10,
    0x41,0xef,0xe0,0x04,0x38,0x03,0x9c,0xe4,0x67,0x8e,0x0c,0x18,0x30,0x43,0x02,0x10,
    0x41,0xe0,0x00,0x04,0x7e,0x07,0x8e,0xe7,0xc3,0xde,0x1f,0xf0,0x10,0x71,0xf1,0xe0,
    0x41,0xc0,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,
    0x41,0x80,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,
    0x41,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,
    0x60,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xc0,0x00,0x00,0x00,
    0x20,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
    0x30,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x18,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x07,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // Remaining rows — blank
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
];

/// Thread-safe handle to a shared I2C bus.
pub type SharedBus = &'static Mutex<I2cDriver<'static>>;

// ---------------------------------------------------------------------------
// SSD1306 command constants
// ---------------------------------------------------------------------------
const CMD_DISPLAY_OFF: u8 = 0xAE;
const CMD_DISPLAY_ON: u8 = 0xAF;
const CMD_SET_DISPLAY_CLOCK: u8 = 0xD5;
const CMD_SET_MULTIPLEX: u8 = 0xA8;
const CMD_SET_DISPLAY_OFFSET: u8 = 0xD3;
const CMD_SET_START_LINE: u8 = 0x40;
const CMD_CHARGE_PUMP: u8 = 0x8D;
const CMD_MEMORY_MODE: u8 = 0x20;
const CMD_SEG_REMAP: u8 = 0xA1;
const CMD_COM_SCAN_DEC: u8 = 0xC8;
const CMD_SET_COM_PINS: u8 = 0xDA;
const CMD_SET_CONTRAST: u8 = 0x81;
const CMD_SET_PRECHARGE: u8 = 0xD9;
const CMD_SET_VCOMH: u8 = 0xDB;
const CMD_DISPLAY_ALL_ON_RESUME: u8 = 0xA4;
const CMD_NORMAL_DISPLAY: u8 = 0xA6;
const CMD_SET_COLUMN_ADDR: u8 = 0x21;
const CMD_SET_PAGE_ADDR: u8 = 0x22;

// I2C control bytes
const CTRL_CMD: u8 = 0x00;  // Co=0, D/C#=0 → command
const CTRL_DATA: u8 = 0x40; // Co=0, D/C#=1 → data

// ---------------------------------------------------------------------------
// OledDisplay — frame-buffered SSD1306 driver
// ---------------------------------------------------------------------------
pub struct OledDisplay {
    bus: SharedBus,
    buffer: [u8; DISPLAY_BUFFER_SIZE],
}

impl OledDisplay {
    pub fn new(bus: SharedBus) -> Self {
        Self {
            bus,
            buffer: [0u8; DISPLAY_BUFFER_SIZE],
        }
    }

    // -- low-level helpers --------------------------------------------------

    fn send_command(&self, cmd: u8) -> anyhow::Result<()> {
        let mut bus = self.bus.lock().unwrap();
        bus.write(I2C_ADDR_OLED, &[CTRL_CMD, cmd], I2C_TIMEOUT_TICKS)?;
        Ok(())
    }

    fn send_commands(&self, cmds: &[u8]) -> anyhow::Result<()> {
        let mut bus = self.bus.lock().unwrap();
        for &cmd in cmds {
            bus.write(I2C_ADDR_OLED, &[CTRL_CMD, cmd], I2C_TIMEOUT_TICKS)?;
        }
        Ok(())
    }

    // -- public API ---------------------------------------------------------

    /// Probe whether the OLED answers on the I2C bus.
    pub fn is_connected(&self) -> bool {
        let mut bus = self.bus.lock().unwrap();
        // Send a NOP-like command; success means ACK received.
        bus.write(I2C_ADDR_OLED, &[CTRL_CMD, CMD_DISPLAY_ALL_ON_RESUME], I2C_TIMEOUT_TICKS)
            .is_ok()
    }

    /// Full SSD1306 initialization sequence for a 128×64 panel.
    pub fn init(&mut self) -> anyhow::Result<()> {
        self.send_commands(&[
            CMD_DISPLAY_OFF,
            CMD_SET_DISPLAY_CLOCK, 0x80,
            CMD_SET_MULTIPLEX, 0x3F,          // 64 lines
            CMD_SET_DISPLAY_OFFSET, 0x00,
            CMD_SET_START_LINE,               // line 0
            CMD_CHARGE_PUMP, 0x14,            // enable charge pump
            CMD_MEMORY_MODE, 0x00,            // horizontal addressing
            CMD_SEG_REMAP,                    // column 127 = SEG0
            CMD_COM_SCAN_DEC,                 // scan from COM63 to COM0
            CMD_SET_COM_PINS, 0x12,           // alt COM pin config
            CMD_SET_CONTRAST, 0xCF,
            CMD_SET_PRECHARGE, 0xF1,
            CMD_SET_VCOMH, 0x40,
            CMD_DISPLAY_ALL_ON_RESUME,
            CMD_NORMAL_DISPLAY,
            CMD_DISPLAY_ON,
        ])?;

        self.clear_buffer();
        self.flush()?;
        log::info!("SSD1306 OLED initialised (128x64)");
        Ok(())
    }

    /// Zero the frame buffer (does NOT flush to hardware).
    pub fn clear_buffer(&mut self) {
        self.buffer.fill(0);
    }

    /// Push the entire frame buffer to the display over I2C.
    pub fn flush(&self) -> anyhow::Result<()> {
        // Set addressing window to full screen
        self.send_commands(&[CMD_SET_COLUMN_ADDR, 0, 127])?;
        self.send_commands(&[CMD_SET_PAGE_ADDR, 0, 7])?;

        // Send buffer page-by-page (128 data bytes + 1 control byte per page)
        let mut bus = self.bus.lock().unwrap();
        let mut page_buf = [0u8; 129];
        page_buf[0] = CTRL_DATA;

        for page in 0..8 {
            let start = page * 128;
            page_buf[1..].copy_from_slice(&self.buffer[start..start + 128]);
            bus.write(I2C_ADDR_OLED, &page_buf, I2C_TIMEOUT_TICKS)?;
        }
        Ok(())
    }

    /// Power off the display panel (OLED segments off, low power).
    pub fn turn_off(&self) -> anyhow::Result<()> {
        self.send_command(CMD_DISPLAY_OFF)
    }

    /// Power on the display panel.
    pub fn turn_on(&self) -> anyhow::Result<()> {
        self.send_command(CMD_DISPLAY_ON)
    }

    // -- high-level screens -------------------------------------------------

    /// Show the PlastiBytes logo bitmap full-screen.
    pub fn show_logo(&mut self) -> anyhow::Result<()> {
        // The logo constant is in row-major bit format (MSB-first per byte, row by row).
        // SSD1306 GDDRAM is in page format (each byte = 8 vertical pixels in a column).
        // We must convert from row-major to page format.
        self.clear_buffer();
        for y in 0..64u32 {
            for x in 0..128u32 {
                let src_byte = (y * 16 + x / 8) as usize;
                let src_bit = 7 - (x % 8);
                if (LOGO_BITMAP[src_byte] >> src_bit) & 1 == 1 {
                    let page = (y / 8) as usize;
                    let bit = y % 8;
                    self.buffer[page * 128 + x as usize] |= 1 << bit;
                }
            }
        }
        self.flush()
    }

    /// Show centred text on a blank screen (used for boot splash).
    pub fn show_centered_text(&mut self, text: &str) -> anyhow::Result<()> {
        self.clear_buffer();
        let style = MonoTextStyle::new(&FONT_6X10, BinaryColor::On);
        let x = 64; // centre of 128-px wide screen
        let y = 34; // roughly vertically centred
        Text::with_alignment(text, Point::new(x, y), style, Alignment::Center)
            .draw(self)
            .unwrap(); // draw to buffer never fails
        self.flush()
    }

    /// Default UI: logo + "PlastiBytes" label underneath.
    pub fn show_default_ui(&mut self) -> anyhow::Result<()> {
        self.show_logo()?;
        // Overlay text at bottom (logo occupies upper ~45 rows)
        let style = MonoTextStyle::new(&FONT_6X10, BinaryColor::On);
        Text::with_alignment("PlastiBytes", Point::new(64, 60), style, Alignment::Center)
            .draw(self)
            .unwrap();
        self.flush()
    }

    /// Activity display: animated character + battery indicator top-right.
    pub fn show_activity(
        &mut self,
        activity: ActivityClass,
        battery_pct: f32,
        animation_state: &AnimationState,
    ) -> anyhow::Result<()> {
        self.clear_buffer();

        // Battery icon (top-right corner)
        self.draw_battery(battery_pct);

        // Draw animated character sprite centered
        let sprite_data = crate::drivers::sprites::get_sprite_frame(activity, animation_state.current_frame());
        let sprite_pos = Point::new(
            SPRITE_CENTER_X - 16, // Center 32px sprite (32/2 = 16)
            SPRITE_CENTER_Y - 16,
        );
        crate::drivers::sprites::draw_sprite(self, sprite_data, sprite_pos)?;

        self.flush()
    }

    /// Boot check result screen.
    pub fn show_boot_status(&mut self, oled_ok: bool, imu_ok: bool) -> anyhow::Result<()> {
        self.clear_buffer();
        let style = MonoTextStyle::new(&FONT_6X10, BinaryColor::On);

        let oled_msg = if oled_ok { "OLED:  OK" } else { "OLED:  FAIL" };
        let imu_msg = if imu_ok { "MPU6050: OK" } else { "MPU6050: FAIL" };

        Text::new(oled_msg, Point::new(20, 24), style).draw(self).unwrap();
        Text::new(imu_msg, Point::new(20, 40), style).draw(self).unwrap();

        self.flush()
    }

    // -- private helpers ----------------------------------------------------

    fn draw_battery(&mut self, level: f32) {
        let clamped = level.clamp(0.0, 100.0);
        let outline = PrimitiveStyle::with_stroke(BinaryColor::On, 1);
        let filled = PrimitiveStyle::with_fill(BinaryColor::On);

        // Battery outline (top-right)
        Rectangle::new(Point::new(108, 0), Size::new(18, 10))
            .into_styled(outline)
            .draw(self)
            .unwrap();

        // Battery tip
        Rectangle::new(Point::new(126, 3), Size::new(2, 4))
            .into_styled(filled)
            .draw(self)
            .unwrap();

        // Fill bar proportional to charge
        let fill_width = ((14.0 * clamped / 100.0) as u32).max(1);
        Rectangle::new(Point::new(110, 2), Size::new(fill_width, 6))
            .into_styled(filled)
            .draw(self)
            .unwrap();
    }
}

// ---------------------------------------------------------------------------
// embedded_graphics::DrawTarget implementation
// ---------------------------------------------------------------------------
impl DrawTarget for OledDisplay {
    type Color = BinaryColor;
    type Error = core::convert::Infallible; // buffer writes cannot fail

    fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
    where
        I: IntoIterator<Item = Pixel<Self::Color>>,
    {
        for Pixel(coord, color) in pixels {
            let x = coord.x;
            let y = coord.y;
            if x >= 0 && x < SCREEN_WIDTH as i32 && y >= 0 && y < SCREEN_HEIGHT as i32 {
                let xu = x as usize;
                let yu = y as usize;
                let page = yu / 8;
                let bit = yu % 8;
                let idx = page * SCREEN_WIDTH as usize + xu;
                if color == BinaryColor::On {
                    self.buffer[idx] |= 1 << bit;
                } else {
                    self.buffer[idx] &= !(1 << bit);
                }
            }
        }
        Ok(())
    }
}

impl OriginDimensions for OledDisplay {
    fn size(&self) -> Size {
        Size::new(SCREEN_WIDTH, SCREEN_HEIGHT)
    }
}
